::
::
::::
  ::
/?    310                             ::  require version 310 or below
/-    message                         ::  import message structure
::
::
::::
  ::
!:                                    ::  insert stack trace
|%                                    ::  core with data-structures
++  move  (mold note gift)            ::  system calls
++  note  $:  %g  %mess p=hapt
          q=ship r=cage
          ==
++  gift
  $:  %g
  $%  [%nice ~]
      [%rush %json json]
  ==  ==
++  hapt  ,[p=ship q=path]            ::  app instance
--
::
!:                                    ::  insert stack trace
|_  $:  hid=hide                      ::  system data
      sent=(map ,@da message)         ::  app-specific data-structures
    received=(map ,@da message)
    ==
::
++  peer                              ::  receive new subscriber on path
  |=  [ost=bone subs=ship pax=path]
  =+  ^=  ordered-messages            ::  push on ordered list of all messages
  %+  sort                            ::  map with quicksort
    (~(tap by received))              ::  over listified map
  |=  $:  a=(pair ,@da message)
      b=(pair ,@da message)
      ==
  (gth p.a p.b)                       ::  compare by time
  :_  +>.$                            ::  return current app state
  ^-  (list move)
  :-  :^  ost  %give  %rush           ::  and send updated inbox
      :-  %json
      (inbox-to-json ordered-messages)
  ~
::
++  inbox-to-json                     ::  convert received messages to ++json
  |=  messes=(list ,[@da message])    ::  accept map of time to message
  :-  %a  ^-  (list json)             ::  compose json object
  %+  turn  messes                    ::  map over listified map of @da to msg
  |=  [tym=time mez=message]          ::  accepts cell of time and message
  %^  jobe                            ::  compose ++json object
    tym/(jode tym)                    ::  k-v pair of tym:time
    mez/(msg-to-json mez)             ::  k-v pair of mez:++json msg
  ~
::
++  msg-to-json                       ::  convert msgs to json
  |=  mez=message                     ::  accept msg
  %^  jobe  to/s/(scot %p to.mez)     ::  compose ++json object of to:shipname
     subj/s/subj.mez                  ::  sub:subject
  :-  body/s/(role body.mez)          ::  body:body-of-msg
  ~                                   ::  jobe takes a list, needs ~ terminator
++  poke-message
  |=  [ost=bone you=ship mez=message]
  ?.  =(to.mez our.hid)               ::  unless we are receiving message:
    =.  sent                          ::  store sent message
    (~(put by sent) [lat.hid [you +.mez]])   
    ^-  [(list move) _+>.$]
    :_  +>.$
    :-  [ost %give %nice ~]
::  send message to other ship
    [ost %pass / %g %mess [to.mez /urbmail] our.hid [%message !>(mez)]]~
  =.  received                        ::  if we're receiving: update received
  (~(put by received) [lat.hid [you +.mez]])
  =+  ^=  ordered-msgs                ::  push on sorted list of messages
  %+  sort                            ::  call sort on
    (~(tap by received))              ::  listified map..
  |=  [a=(pair ,@da message) b=(pair ,@da message)]
  (gth p.a p.b)                       ::  and gate that compares by @da
  :_  +>.$                            ::  tell %gall to maintain same app state
  :-  [ost %give %nice ~]             ::  positive acknowledgement
  %+  turn  (~(tap by sup.hid))       ::  map over list of subscribers
  |=  [os=bone *]                     
  :^  os  %give                       ::  sending them an update
    %rush
  :-(%json `json`(inbox-to-json ordered-msgs))          ::  of new inbox
 ::
++  pour                              ::  handle responses to requests we make
  |=  [ost=bone pax=path sih=*]
  [[ost %give %nice ~]~ +>.$]         ::  confirmation and unaltered state
--
