::    store results of foosball games ::  short descripton
::
::::
  ::
/?  310                               ::  require version 310 or lower
::
::
::::  sivtyv-barnel                   ::  list author(s)
  ::
|%                                    ::  core with data structures
++  axle  (list result)               ::  results of all past games
++  result  ,[bcons=@t bscore=@ud ycons=@t yscore=@ud]
--
!:                                    ::  insert stack trace

::  main app core
|_  [hid=hide vat=axle]               ::  system data, state

::  called whenever  app receives any data from %gall with the
::  type ("mark") of json. 
++  poke-json                         ::  receive JSON
  |=  [ost=bone you=ship args=json]
  ?.  =(/[app.hid] imp.hid)           ::  XX to be antequated
    =+  cag=`cage`[%json !>(args)]    ::  XX will change
    :_(+>.$ [ost %pass /from-child %g %mess [our.hid /[app.hid]] you cag]~)
  =+  ^-  parsedresult=result         ::  push on result of reparsing JSON
      ~|  bad-json/args               ::  produce p in stack trace if q crashes
      %-  need                        ::  crash if ~ (on parse-fail)
      %-  =>  jo                      ::  from ++jo get "ot", obj-tuple parser
::  parse tuple from ++json object "args"
      (ot bcons/so bscore/ni ycons/so yscore/ni ~)
      args
  =.  vat  [parsedresult vat]         ::  change state to [newresult oldstate]
  [[ost %give %nice ~]~ +>.$]         ::  return positive ack and new (unchanged app-state)
::
++  result-to-json                    ::  reassemble json to respond to client
  |=  result
  %-  jobe  :~                        ::  produce ++json object
    bcons/[%s bcons]                  ::  produce ++json string
    ycons/[%s ycons]
    bscore/(jone bscore)              ::  produce ++json number from @u
    yscore/(jone yscore)
  ==

::  called when app receives a subscriber on a new path. subscriber is then
::  added to to sup.hid
++  peek
  |=  [his=ship pax=path]
  [%json `json`[%a (turn vat result-to-json)]]          ::  send all results as ++json to client

++  spam                              ::  send list of results to all subscribers
  |=  ost=bone                        ::  bone of who poked us
  :-  [ost %give %nice ~]             ::  positive ack to whomever poked us
  %+  turn                            ::  map
    (~(tap by sup.hid))               ::  over list of bone-to-path & ship
  |=  [ost=bone *]                    ::  with function that sends each a %rush
  :^  ost  %give  %rush               ::  %rush with updated state
  :-  %json                           ::  mark is %json
  `json`[%a (turn vat result-to-json)]::  produce ++json array of all results
--
