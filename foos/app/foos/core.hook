::    store results of foosball games ::  short descripton
::
::::
  ::
/?  310                               ::  require version 310 or lower
::
::
::::  sivtyv-barnel                   ::  list author(s)
  ::
|%                                    ::  core with data structures
++  axle  (list result)               ::  results of all past games
++  result  ,[bcons=@t bscore=@ud ycons=@t yscore=@ud]
--
!:                                    ::  insert stack trace

::  main core containing our app. it has a "sample" that contains our state.
::  hid contains our system data. vat contains our app-specific state.
::  cores with sample are also called "doors".
|_  [hid=hide vat=axle]               ::  system data, state

::  poke-json is called whenever the app receives any data from %gall with the
::  type ("mark") of json. as a rule, it accepts a bone, a ship of the ship
::  that poked you, as well as an element of the type of data that poked you,
::  which is in this case ++json
++  poke-json                         ::  receive JSON
  |=  [ost=bone you=ship args=json]
  ?.  =(/[app.hid] imp.hid)           ::  send data to parent app
    =+  cag=`cage`[%json !>(args)]    ::  XX will chang
    :_  +>.$  
    [ost %pass /from-child %g %mess [our.hid /[app.hid]] you cag]~
  =+  ^-  parsedresult=result         ::  push on result of reparsing JSON
      ~|  bad-json/args               ::  produce p if q crashes

::  when %eyre receives JSON from the outside world, it parses it to
::  a hoon representation of JSON, called ++json. however, to
::  operate on this data, we must first "reparse" it from ++json
::  to the proper hoon data type first. see ++jo in zuse 3Bd.
::  here all we're doing is reparsing from a ++json object to a tuple.
      %-  need 
      =+  jo
      %-  (ot bcons/so bscore/ni ycons/so yscore/ni ~)
      args
                                      ::  list key-to-parsers
                                      ::  call this parser on "args"
  =.  vat  [parsedresult vat]         ::  update state: [newresult oldresults]

::  any arm that receives information from %gall must return a list of system
::  calls, called moves, as well as the new app state.
::  we don't want to change the  state here, we just set it to +>.$.
::  inside this core, +>.$ refers to the whole contents of this hook file,
::  the only move here--a %nice--informs %gall that we successfully received
::  its message. for more info on this, see the "making moves" section of the
::  arvo reference doc.
  [[ost %give %nice ~]~ +>.$]

::  turn our state into ++json which we can then send to the client via %eyre
++  result-to-json
  |=  result                          ::  accept a result
  %-  jobe  :~                        ::  produce a ++json object
    bcons/[%s bcons]                  ::  produce a ++json string
    ycons/[%s ycons]
    bscore/(jone bscore)              ::  produce a ++json number
    yscore/(jone yscore)
  ==


::  ++peer is called when the app receives a subscription request on a particular
::  path for the first time. it begins with a gate that accepts the ship of the
::  subscriber along with the path to which they want to subscribe.
::  with this information, ++peer does two things: it updates the list of subscribers & their paths
::  in sup.hid. and it sends the subscriber some sort of typed data.
::  generally, we use this feature to send our initial state. after our one-time ++peer,
::  we update the client manually whenever our state changes. we do this above
::  on line XX
++  peer
  |=  [his=ship pax=path]
  [%json `json`[%a (turn vat result-to-json)]]
  ::  don't forget to send %json in front
::
++  spam
  |=  ost=bone
  :_  ~
  :-  [ost %give %nice ~]
  %+  turn  (~(tap by sup.hid))
  |=  [bne=bone *]
  [ost %give %rush %json `json`[%a (turn vat result-to-json)]]
--
