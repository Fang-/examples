::    project euler 14
::    https://projecteuler.net/problem=14
::
::::  /hook/core/euler14/app/main/
  ::  Put this in main/app/ and invoke it with ":euler14 [number]"
::
::
::::  ~haptem-fopnys, ~sivtyv-barnel
  ::
|%
::  ++gift defines the set of responses you give, which the caller receives
::  as a ++sign. this app only gives two responses: a %nice, which is a
::  positive acknowledgment, and a %rush (subscription update), which 
::  fulfills the shell's request for this apps stdout (/out)
++  gift
  $%  [%nice ~]
      [%rush %tang p=tang]
  ==
--
|_  [hid=hide ~]
::  ++peer handles subscription requests (%show) made from through %gall
::  this is automatically called when shell subscribes to the app's output,
::  even before it calls ++poke-euler14-args. In this case, all ++peer
::  does is accept any noun (*), and return an empty list of moves (~) as
::  well as the context of the core, which in this case is the entire app
::  with unaltered state. In other words, ++peer exists only
::  to satisfy %gall's type system.  
++  peer                                
  |=  *
  [~ +>]

::  called when app is called from command line with
::  ':APPNAME [args]'. The first argument is the ++bone (explained in the
::  arvo reference). The second is the ship of the "poker".
::  Any further arguments are those passed to the app via the command line
::  as a list (hence the terminating ~).

++  poke-euler14-args
  |=  [ost=bone you=ship args=@ud ~]
    =+  result=(longcol args)
    :_  +>.$
    :-  [ost %give %nice ~]  (spam [%rush %tang `tang`[>result< ~]])


++  collatz :: given a, returns the number of steps needed to reach 1
  |=  [a=@u]
  ~+ :: enable memoization
  =+  [curr=a len=1] :: initialize variables
  |-  ^-  @u :: output a @u (uint) from the inner closure
  ?:  =(curr 1) :: If curr==1
    len :: return len
  ?:  =((mod curr 2) 0) :: if curr%2==0
    $(curr (div curr 2), len +(len)) :: recurse with curr=curr/2 and len=len+1
  $(curr (add (mul curr 3) 1), len +(len)):: else recurse with curr=curr*3+1 and len=len=1

++  longcol :: find the longest collatz sequence under a
  |=  [a=@u]:: wet gate, a is an unsigned atom
  =+  [len=0 num=0 acc=1] :: initialize variables
  |-  ^-  [@u @u] :: output a [@u @u] tuple aka (uint, uint)
    =+  col=(collatz acc) :: define closure local variable for collatz length
  ?:  =(acc a) :: if acc==a
    [num len] :: return (num, len) tuple
  ?:  (lte len col) :: elseif len<=col 
    $(len col, num acc, acc +(acc)) :: recurse with len=col, num=acc, acc=acc+1
  $(acc +(acc)) :: else recurse with acc=acc+1
--

::  this arm is used to send the app's stdout (a %rush ++gift) to whatever
::  has subscribed to its /out.  
++  spam
  |=  git=gift
  %+  turn
    (~(tap in (~(get ju pus.hid) /out)))
  |=(a=bone [a %give git])
--
